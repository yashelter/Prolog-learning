## Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

## Введение

Существует множество подходов к решению логических задач, например методы : рассуждений, таблиц, алгебры логики, кругов Эйлера, многие другие и программирование на Прологе. 

И преимущество решения логических задач программированием на Прологе состоит в том, что сам его синтаксис это логические утверждения и правила, что позволяет практически дословно описать задачу в рамках синтаксиса Пролога. 

Данный подход даёт большое преумущество при описании задач, где код на  императивных языках, а тем более вычисления вручную, будут более сложны для понимания и громоздки

## Задание

#### Вариант №9 (по списку 9)

Один из пяти братьев разбил окно.

- Андрей сказал: Это или Витя, или Толя. 
- Витя сказал: Это сделал не я и не Юра.
- Дима сказал: Нет, один из них сказал правду, а другой неправду. 
- Юра сказал: Нет, Дима ты не прав. 
- Их отец, которому, конечно можно доверять, уверен, что не менее трех братьев сказали правду.

Кто разбил окно?

## Принцип решения
#### Идея решения
Опишем каждое утверждение, в виде его проверки для виновности каждого из братьев, например:
```prolog
% Андрей : Это или Витя, или Толя
statement("Andrey", Target):- Target = "Vitya"; Target = "Tolya".
```

Затем будем проверять для выбранного подозреваемого, выполняются ли для него утверждения.

```prolog
% Проверяем виновен ли подозреваемый
check([], _).
check([Head | Tail], Target):- statement(Head, Target), check(Tail, Target).
```
Заметим, что не обязательно проверять все утверждения, так как два из них противоречат друг другу, а исходя из слов отца (которому *можно* верить), можно считать, что как минимум один из братьев соврал, Т.е число истинных утверждений равно трём. 

Тогда будем перебирать всех потенциальных подозреваемых, и вычёркивать одно из утверждений:

```prolog
humans(Humans) :- Humans = ["Andrey", "Vitya", "Dima", "Yuri", "Tolya"].

solve(Target):-
    humans(All),
    delete(All, "Tolya", Speaked), % он ничего не говорил

    member(Target, All), % выбор того кто виновен
    member(Liar, Speaked), % выбор того кто солгал

    delete(Speaked, Liar, Correct), % не берём утверждение солгавшего на проверку
    
    check(Correct, Target). % проверяем все утверждения, для текущего подозреваемого

``` 
По итогу найдём того кто виновен:

```prolog
get_answer(R) :- solve(R), write('Window was broken by : '), write(R).
```
</br>

#### Итоговый Ответ
<details>
<summary>И виновным оказался:</summary>

```prolog
?- get_answer(R).
Window was broken by : Tolya
R = "Tolya" ;
false.
```
**Толя!**
</details>


## Выводы

Начнём с оценки итоговой программы. В моём решении для каждого из братьев ```(n)```, как подозреваемых, выкидывали одно точно неверное утверждение ```(n-2)```, и их проверяли ```(n-2)```. Поэтому итоговая сложность составила ```n*(n-2)*(n-2) ≈ n^3```  либо ```5*3*3 = 45 операций```, а без оптимизации была бы ```n*(n-1)*(n-1) ≈ n^3```  либо ```5*4*4 = 80 операций```, что почти в 2 раза больше полученной. Также видно, что было найдено одно единственное решение и не произошло зацикливание программы.

По итогу, данная работа научила меня искать оптимальное решение, напомнила об ассиптотической оценке кода, помогла связать уже имеющиеся знания (лабораторная работа №1) с новыми, и ознакомила с решением логических задач (на примере задачи №9). По ходу решения я понял, что Пролог является прекрасным инструментом, в виду удобной рекурсии на любом этапе программы (предикат ```solve```), в особенности для решения логических задач, ведь их решение *вручную* может быть не тривиальным, а код на других императивных языках может быть также сложным и громоздким.

Эта работа продолжила подогревать мой интерес к програмированию на Прологе, и надеюсь, что следующая не будет уступать предыдущим!